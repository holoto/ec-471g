#!/bin/sh

# A script to launch DarwinDumper and respond to user input.
# Copyright (C) 2013-2015 Blackosx
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# =======================================================================
#
# This script responds to user input and launches DarwinDumper
# either via the user interface or the command line depending
# on how it was run.
#
# The user interface gathers the options the user wants and
# then writes those options to a file ready for the main
# DarwinDumper script to read.
#
# Alternatively, command line options are parsed and written
# to file ready for the main DarwinDumper script to read.
#
# This script then sits and waits until the UI terminates
# before also terminating.
#

gFaceless=0 # Set to 1 to build app which when double-clicked does not show UI but runs all without root privileges.

gDDTmpFolder="/tmp/DarwinDumper" # Temporary working folder.
gReportsFolderPath="" # Directory path for DarwinDumper reports.
gTmpPreLogFile="$gDDTmpFolder"/tmplogfile
gUserPrefsFileName="org.tom.DarwinDumper"
gUserPrefsFile="$HOME/Library/Preferences/$gUserPrefsFileName"
VERS="2.9.9.2"

# ---------------------------------------------------------------------------------------
Initialise()
{
    passedCaller="$1"
    asUser="$2"

    # write version to temp file for UI to use.
    # Previously used export fails when running as root.
    echo "$VERS" > "$gDDTmpFolder"/dd_version

    gAppReportsFolderName="DarwinDumperReports"
    gUiPwCancelledStr="zYx1!dd_User_Cancelled!!xYz"

    # Here we save the current user and group ID's and use them in the
    # DarwinDumper script when setting ownership/permissions of the dump
    # folder, even if the user opt to run the dumps with root privileges.
    DD_BOSS=`id -unr` #export DD_BOSS=`id -unr`
    DD_BOSSGROUP=`id -gnr` #export DD_BOSSGROUP=`id -gnr`

    # The problem with the above is if the user has invoked sudo with root privileges
    # and runs DarwinDumper then the UID will be root and the DarwinDumperReports folder
    # will be created and owned by root.
    # Here we check to see if the current user is root and if yes then change it
    # using the environment variable $HOME.
    # ** THIS NEEDS CHECKING - Does it work for everyone?
    if [ "$DD_BOSS" == "root" ]; then
        DD_BOSS=$(echo "${HOME##*/}")
        DD_BOSSGROUP=`id -g -n ${DD_BOSS}`
    fi

    # The above works great when using the command line, but not the UI.
    # So we need to write them to a file instead and read them later.
    echo "${DD_BOSS}:${DD_BOSSGROUP}" > "$gDDTmpFolder"/dd_user

    # From http://stackoverflow.com/questions/7665/how-to-resolve-symbolic-links-in-a-shell-script/697552#697552
    # get the absolute path of the executable
    #SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")

    # resolve symlinks
    #while [ -h "$SELF_PATH" ]; do
        # 1) cd to directory of the symlink
        # 2) cd to the directory of where the symlink points
        # 3) get the pwd
        # 4) append the basename
    #    DIR=$(dirname -- "$SELF_PATH")
    #    SYM=$(readlink "$SELF_PATH")
    #    SELF_PATH=$(cd $DIR && cd $(dirname -- "$SYM") && pwd)/$(basename -- "$SYM")
    #done

    # The final platypus built app has this script located at:
    # /DarwinDumper.app/Contents/Resources/script
    # So to find the application containing directory we have to move up 4 dirs.
    appRootPath="${SELF_PATH}"
    for (( x=1; x<=4; x++ ))
    do
        appRootPath="${appRootPath%/*}"
    done

    # Write actual app path to file also, so UI can compare paths
    # To know if a custom path is being used.
    echo "$appRootPath" > "$gDDTmpFolder"/dd_app_root_path

    # Check prefs for previously used settings and to find if the user
    # previously set a custom directory for the DarwinDumperReports folder.
    if [ $gFaceless -eq 0 ]; then
        LoadPreviousSettingsFromUserPrefs
    fi

    local resourcesDir="${SELF_PATH%/*}"
    if [ -d "$resourcesDir" ]; then
        local scriptsDir="$resourcesDir"/Scripts
        darwinDumperScript="$scriptsDir/DarwinDumper.sh"
        macgap="$resourcesDir/MacGap.app/Contents/MacOS/MacGap"
        uiSudoChanges="$resourcesDir/Scripts/uiSudoChangeRequests.sh"

        if [ "$passedCaller" == "Script" ]; then
            runUI
        elif [ "$passedCaller" == "CommandLine" ]; then
            runCommandLine "$asUser"
        fi
    else
        echo "DarwinDumper quit because it couldn't find the Resources folder."
        exit 1
    fi
}

# ---------------------------------------------------------------------------------------
CheckAndFixBlankSavePath()
{
    # Is the current save path blank?
    # If yes, then set the save path to the app containing dir.
    if [ "$gReportsFolderPath" == "" ]; then
        gReportsFolderPath="$appRootPath"
        echo "*Save path - Default: Will use $gReportsFolderPath" >> "$gTmpPreLogFile"
    fi
}

# ---------------------------------------------------------------------------------------
CheckForExistingReportsDirAndAppend()
{
    # check for existing DarwinDumperReports dir at save location.
    if [ -d "$gReportsFolderPath"/"${gAppReportsFolderName}" ]; then
        gReportsFolderPath="$gReportsFolderPath"/"${gAppReportsFolderName}"
    fi
}

# ---------------------------------------------------------------------------------------
DoesSavePathExist()
{
    passedPath="$1"
    if [ -d "$passedPath" ]; then
        echo "*Save path verify: Path exists." >> "${gTmpPreLogFile}"
        return 0
    else
        echo "*Save path verify: Path does not exist." >> "${gTmpPreLogFile}"
        return 1
    fi
}

# ---------------------------------------------------------------------------------------
CheckPathIsWriteable()
{
    local passedDir="$1"

    local isWriteable=1
    touch "$passedDir"/test 2>/dev/null && rm -f "$passedDir"/test || isWriteable=0
    local reportsFolderOwner=$( ls -ld "$passedDir" | awk '{print $3}' )

    if [ ! "$DD_BOSS" == "$reportsFolderOwner" ] || [ $isWriteable -eq 0 ]; then
        echo "*Save path verify: Path is not writeable." >> "${gTmpPreLogFile}"
        return 1
    else
        echo "*Save path verify: Path is writeable." >> "${gTmpPreLogFile}"
        return 0
    fi
}

# ---------------------------------------------------------------------------------------
CheckSavePathForReportsName()
{
    # Does the current save path end with DarwinDumperReports?
    local tmp="${gReportsFolderPath##*/}"
    if [ "$tmp" == "$gAppReportsFolderName" ]; then
        echo "*Save path verify: Path ends with ${gAppReportsFolderName}." >> "${gTmpPreLogFile}"
        return 0
    else
        echo "*Save path verify: Path does not end with ${gAppReportsFolderName}." >> "${gTmpPreLogFile}"
        return 1
    fi
}

# ---------------------------------------------------------------------------------------
createSaveDirAndSetPermissions()
{
    declare -a list

    MatchNameToID()
    {
        local match=""
        for (( i=0; i<${#list[@]}; i++ ))
        do
            if [[ "${list[$i]}" == *$1* ]]; then
                match="${list[$i]##*=}"
                match="${match%(*}"
                break
            fi
        done
        echo "$match"
    }

    local passedDir="$1"
    local passedCommand="$2"
    local passedTask="$3"
    local passedCaller="$4"
    local passedMessage="$5"

    if [ "$passedCommand" == "normal" ]; then
        if [ "$passedTask" == "CreateSet" ]; then
            # The path is writeable so create directory
            echo "*Save path: Creating ${passedDir}" >> "${gTmpPreLogFile}"
            mkdir "${passedDir}"
        fi
    fi

    if [ "$passedCommand" == "sudo" ]; then
        if [ "$passedTask" == "CreateSet" ]; then
            # The path is not writeable so create directory with root privileges
            if [ "$passedCaller" == "UI" ]; then
                GetAndCheckUIPassword "$passedMessage"
                local returnValueRoot=$? # 1 = not root / 0 = root

                if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then
                    echo "*Save path: Creating ${passedDir} and setting permissions." >> "${gTmpPreLogFile}"
                    echo "$gPw" | sudo -S "$uiSudoChanges" "CreateFolderSetPerms" "${DD_BOSS}" "${DD_BOSSGROUP}" "${passedDir}" && gPw=""

                    echo "*Save path: Setting permissions for ${gReportsFolderPath}." >> "${gTmpPreLogFile}"
                    echo "$gPw" | sudo -S "$uiSudoChanges" "OwnPerm" "${DD_BOSS}" "${DD_BOSSGROUP}" "${passedDir}" && gPw=""
                fi
            elif [ "$passedCaller" == "CL" ]; then
                echo "Creating ${passedDir}"
                sudo mkdir "${passedDir}"
                echo "Setting owner and group to ${DD_BOSS}:${DD_BOSSGROUP}"
                sudo chown "${DD_BOSS}":"${DD_BOSSGROUP}" "${passedDir}"
                echo "Setting permissions to 755"
                sudo chmod -R 755 "${passedDir}"
            fi
        fi
        if [ "$passedTask" == "Set" ]; then
            # The path is not writeable so create directory with root privileges
            if [ "$passedCaller" == "UI" ]; then
                GetAndCheckUIPassword "$passedMessage"
                local returnValueRoot=$? # 1 = not root / 0 = root

                if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then
                    echo "*Save path: Setting permissions for ${gReportsFolderPath}." >> "${gTmpPreLogFile}"
                    echo "$gPw" | sudo -S "$uiSudoChanges" "OwnPerm" "${DD_BOSS}" "${DD_BOSSGROUP}" "${passedDir}" && gPw=""
                fi
            elif [ "$passedCaller" == "CL" ]; then
                echo "Setting owner and group to ${DD_BOSS}:${DD_BOSSGROUP}"
                sudo chown "${DD_BOSS}":"${DD_BOSSGROUP}" "${passedDir}"
                echo "Setting recursive permissions to 755"
                sudo chmod -R 755 "${passedDir}"
            fi
        fi
    fi

    # Check success.
    local reportsPerms=$( stat -f "%p" "${passedDir}" )
    local reportsDirUser=$( stat -f "%u" "${passedDir}" ) # will be the number
    local reportsDirGroup=$( stat -f "%g" "${passedDir}" ) # will be the number
    reportsPerms=${reportsPerms:2:5}

    # cross reference the ID numbers against the names we wanted to set using ${DD_BOSS}:${DD_BOSSGROUP}
    oIFS="$IFS"; IFS=$' ,'
    list=( $(id) )
    IFS="$oIFS"

    local ddBossUID=$(MatchNameToID "${DD_BOSS}")
    local ddBossGID=$(MatchNameToID "${DD_BOSSGROUP}")

    echo "*Save path: Currently owned by user:$reportsDirUser of group:$reportsDirGroup with permissions: $reportsPerms" >> "${gTmpPreLogFile}"

    # Return success or failure
    if [ "$reportsDirUser" == "$ddBossUID" ] && [ "$reportsDirGroup" == "$ddBossGID" ]; then
        echo "*Save path: ${passedDir} is now owned by ${DD_BOSS}:${DD_BOSSGROUP} with permissions $reportsPerms" >> "${gTmpPreLogFile}"
        if [ ${reportsPerms:0:1} == "7" ]; then
            if [ "$passedCaller" == "CL" ]; then
                echo "${passedDir} has permissions $reportsPerms"
                echo "------------------------------------------------------------------------"
            fi
            return 0
        else
            echo "*Save path: Failed to change permissions for ${passedDir}" >> "${gTmpPreLogFile}"
            if [ "$passedCaller" == "CL" ]; then
                echo "*** Failed to change permissions for ${passedDir}"
                echo "------------------------------------------------------------------------"
            fi
            return 1
        fi
    else
        echo "*Save path: Ownership error for ${passedDir}" >> "${gTmpPreLogFile}"
        echo "*Save path: Failed to match user:$ddBossUID of group:$ddBossGID" >> "${gTmpPreLogFile}"
        if [ "$passedCommand" == "sudo" ]; then
            echo "*Save path: Failed to change ownership/permissions for ${passedDir}" >> "${gTmpPreLogFile}"
        fi

        if [ "$passedCaller" == "CL" ]; then
            echo "*** Failed to change ownership/permissions for ${passedDir}"
        fi
        return 1
    fi
}

# ---------------------------------------------------------------------------------------
BailOut()
{
    local passedMessage="$1"

    echo "$passedMessage"
    echo "Exiting."
    DeleteTempWorkingDirectory
    echo "Bye."
    exit 1
}

# ---------------------------------------------------------------------------------------
CheckForUpdate()
{
    # Simple check to compare version number of this version number against the
    # newest download file on bitbucket. If there's a difference then the version number
    # from bitbucket is written to tmp/dd_update for reading by darwindumper.js
    if [ -f /usr/bin/curl ]; then
        local testConnection=$( /usr/bin/curl --silent --head https://bitbucket.org/blackosx/darwindumper/downloads | egrep "OK"  )
        if [ "$testConnection" ]; then
            local checkVer=""
            checkVer=$( /usr/bin/curl --silent https://bitbucket.org/blackosx/darwindumper/downloads | grep DarwinDumper_v*.*.*.zip | head -n 1 )
            if [ "$checkVer" == "" ]; then
                echo "No update available." >> "$gTmpPreLogFile"
            else
                # Strip version from returned line
                checkVer="${checkVer##*DarwinDumper_v}"
                checkVer="${checkVer%.zip*}"

                # Remove any non-numeric chars from version numbers
                local checkNewVerNumber=$( echo "$checkVer" | sed 's/\([0-9][0-9]*\)[^0-9]*/\1/g' )
                local checkCurrentVerNumber=$( echo "$VERS" | sed 's/\([0-9][0-9]*\)[^0-9]*/\1/g' )
                
                # Do num lengths match? (300 = 299)
                if [ ${#checkNewVerNumber} -eq ${#checkCurrentVerNumber} ]; then
                    if [ $checkNewVerNumber -gt $checkCurrentVerNumber ]; then
                        echo "*Version check: Newer v${checkVer} is available." >> "$gTmpPreLogFile"
                        echo "$checkVer" > "$gDDTmpFolder"/dd_update
                    fi
                    
                #  Is new repo number length shorter then current number length?
                elif [ ${#checkNewVerNumber} -lt ${#checkCurrentVerNumber} ]; then
                    if [ $checkNewVerNumber -gt ${checkCurrentVerNumber:0:${#checkNewVerNumber}} ]; then
                       echo "*Version check: Newer v${checkVer} is available." >> "$gTmpPreLogFile"
                        echo "$checkVer" > "$gDDTmpFolder"/dd_update
                    fi
                
                # Is new number length longer then current number length?
                elif [ ${#checkNewVerNumber} -gt ${#checkCurrentVerNumber} ]; then
                    # Compare new vs current (up to curent length)
                    if [ ${checkNewVerNumber:0:${#checkCurrentVerNumber}} -gt $checkCurrentVerNumber ]; then
                        echo "*Version check: Newer v${checkVer} is available." >> "$gTmpPreLogFile"
                        echo "$checkVer" > "$gDDTmpFolder"/dd_update
                    # Current length of numbers match - this must be a point update
                    elif [ ${checkNewVerNumber:0:${#checkCurrentVerNumber}} -eq $checkCurrentVerNumber ]; then
                        echo "*Version check: Newer v${checkVer} is available." >> "$gTmpPreLogFile"
                        echo "$checkVer" > "$gDDTmpFolder"/dd_update
                    fi
 
                else
                    echo "*Version check: This is the latest version." >> "$gTmpPreLogFile"
                fi
            fi
        fi
    fi
}

# ---------------------------------------------------------------------------------------
LoadPreviousSettingsFromUserPrefs()
{
    # Check for preferences file
    if [ -f "$gUserPrefsFile".plist ]; then

        oIFS="$IFS"; IFS=$'\n'
        local readVar=( $( defaults read "$gUserPrefsFile" 2>/dev/null ) )
        IFS="$oIFS"

        # get total count of lines, less one for zero based index.
        local count=(${#readVar[@]}-1)

        # Check first line and last line of prefs file actually is an open and closing curly brace.
        if [[ "${readVar[0]}" == "{" ]] && [[ "${readVar[$count]}" == "}" ]]; then
            echo "*Reading ${gUserPrefsFile}.plist" >> "$gTmpPreLogFile"

            # Ignore first and last elements as they will be an opening and closing brace.
            for (( x=1; x<$count; x++ ))
            do
                # separate items
                local tmpOption="${readVar[$x]%=*}"
                local tmpValue="${readVar[$x]#*=}"
                # Remove whitespace
                tmpOption="${tmpOption//[[:space:]]}"

                # Check for save directory.
                if [ "$tmpOption" == "SaveDirectory" ]; then
                    # Remove quotes and semicolon from the returned string
                    tmpValue=$( echo "$tmpValue" | tr -d '";' )
                    # Remove any leading white space
                    tmpValue=$( echo "${tmpValue#* }" )
                    # Escape any spaces - but not for El Capitan
                    osVer=$( uname -r )
                    osVer="${osVer%%.*}"
                    if [ $osVer -lt 15 ]; then
                        tmpValue=$( echo "$tmpValue" | sed 's/ /\\ /g' )
                    fi
                    gReportsFolderPath="$tmpValue"
                    echo "*Found save path $gReportsFolderPath" >> "$gTmpPreLogFile"
                else
                    # Remove whitespace
                    tmpValue="${tmpValue//[[:space:]]}"
                fi

                # If true AND the app was initiated from the Finder (not command line) then set options for loading.
                if [ "$tmpValue" == "True;" ]; then #&& [ "$passedCaller" == "Script" ]; then
                    # Check for enablehtml option from v2.9.2 and older and update with new Report option for v2.9.9 and newer.
                    if [ "$tmpOption" == "enablehtml" ]; then
                        tmpOption="Report"
                    fi
                    echo "$tmpOption" >> "$gDDTmpFolder"/dd_user_last_options
                    echo "*Found previous option: $tmpOption" >> "$gTmpPreLogFile"
                fi
            done
        else
            echo "*$gUserPrefsFile does not contain opening and closing curly braces." >> "$gTmpPreLogFile"
        fi
    else
        echo "*$gUserPrefsFile not found." >> "$gTmpPreLogFile"
    fi
}

# ---------------------------------------------------------------------------------------
CheckSymLink()
{
    if [ -L /usr/local/bin/darwindumper ]; then
        local checkSymLink=$( readlink -n /usr/local/bin/darwindumper )
        if [ ! "$checkSymLink" == "$SELF_PATH" ]; then
            # Existing symlink doesn't match this. Give the user the option to update?
            echo "*Symlink check: Symlink exists, but does not point to this version of the app." >> "$gTmpPreLogFile"
            # write status to temp file for UI to use.
            echo "Update" > "$gDDTmpFolder"/dd_symlink
        else
            echo "*Symlink check: Symlink exists and is correct." >> "$gTmpPreLogFile"
            echo "Okay" > "$gDDTmpFolder"/dd_symlink
        fi
    else
        # No symlink exists. Give the user the option to create one?
        echo "*Symlink check: Symlink has not been created." >> "$gTmpPreLogFile"
        # write status to temp file for UI to use.
        echo "Create" > "$gDDTmpFolder"/dd_symlink
    fi
}

# ---------------------------------------------------------------------------------------
ClearUIReturnMessages()
{
    # Clear "$gDDTmpFolder"/dd_ui_return so the main loop can
    # continue waiting for further user input
    if [ -f "$gDDTmpFolder"/dd_ui_return ]; then
        > "$gDDTmpFolder"/dd_ui_return
    fi
}

# ---------------------------------------------------------------------------------------
ClearAuthMessage()
{
    # Give the UI a chance to close the authentication message box
    # just incase it's stil visible.
    echo "Done" > "$gDDTmpFolder"/dd_auth
    sleep 1

    # Remove user authentication message file for UI.
    if [ -f "$gDDTmpFolder"/dd_auth ]; then
        rm "$gDDTmpFolder"/dd_auth
    fi
}

# ---------------------------------------------------------------------------------------
ClearUIErrorMessage()
{
    # Give the UI a chance to see this message and present dialog
    # box before deleting this message.
    sleep 1

    # Remove user authentication message file for UI.
    if [ -f "$gDDTmpFolder"/dd_error ]; then
        rm "$gDDTmpFolder"/dd_error
    fi
}

# ---------------------------------------------------------------------------------------
GetNewSaveDirectory()
{
    # Send message to UI to tell it we're waiting for user action
    echo "Waiting" > "$gDDTmpFolder"/dd_waiting

    # show tiny dialog box - as an attempt to ensure choose folder dialog box is shown
    local tmp="$( /usr/bin/osascript -e 'Tell application "System Events" to display dialog "Click this button to continue. (Yes I know its stupid having this but Applescript from shell seems buggy!!)" buttons {"Show folder browser"}' 2>/dev/null )"

    #local myFolder="$( /usr/bin/osascript -e 'with timeout of 10 seconds' -e 'Tell application "System Events" to set sourceFolder to (choose folder with prompt "Select a new path for the DarwinDumperReports folder.") as text ' -e 'end timeout' 2>/dev/null)"
    local myFolder="$( /usr/bin/osascript -e 'Tell application "System Events" to set sourceFolder to (choose folder with prompt "Choose a save directory for the DarwinDumperReports folder to be created
or select an existing DarwinDumperReports folder.") as text ' 2>/dev/null)"

    if [ ! "$myFolder" == "" ]; then

        # Note: returned string will look something like this MountainLion:Users:whoever:Desktop:test:
        # Change colons to forward slashes
        myFolder=$( echo "$myFolder" | sed 's/:/\//g' )
        # Strip last character
        myFolder=$( echo "${myFolder%?}" )
        # Append /Volumes/
        myFolder="/Volumes/$myFolder"

        # Escape spaces - but not for El Capitan
        # Check os version
        osVer=$( uname -r )
        osVer="${osVer%%.*}"
        if [ $osVer -lt 15 ]; then
            myFolder=$( echo "$myFolder" | sed 's/ /\\ /g' )
        fi

        # Is the new path different to what we had before?
        if [ ! "$myFolder" == "$gReportsFolderPath" ]; then
            gReportsFolderPath="$myFolder"

            # Check if path contains parenthesis - if yes, do not write to prefs.
            if [[ ! "$gReportsFolderPath" == *\(* ]] && [[ ! "$gReportsFolderPath" == *\)* ]]; then
                # Write new path to prefs file.
                defaults write "$gUserPrefsFile" SaveDirectory "$gReportsFolderPath"
            fi
        fi
   fi

   # Check if path contains parenthesis - if yes, do not report back.
   if [[ ! "$gReportsFolderPath" == *\(* ]] && [[ ! "$gReportsFolderPath" == *\)* ]]; then

       CheckForExistingReportsDirAndAppend

       # remove temp file holding file path.
       if [ -f "$gDDTmpFolder"/dd_reports_filepath ]; then
           rm "$gDDTmpFolder"/dd_reports_filepath
       fi

       # Write new (or old) path to file for UI to read.
       echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
       echo "*Save path: User changed to $gReportsFolderPath" >> "$gTmpPreLogFile"
   fi

   # Send message to UI to let it know it's no longer waiting for user action
   echo "Done" > "$gDDTmpFolder"/dd_waiting

   # As the JS looks for the string Done in "$gDDTmpFolder"/dd_waiting, the
   # UI file browser dialog will not be drawn again while it's still present.
   # Simple solution is to wait 1 second then delete the file.
   sleep 1
   rm "$gDDTmpFolder"/dd_waiting
}

# ---------------------------------------------------------------------------------------
ClearSaveDirectory()
{
    # remove temp file holding file path.
    if [ -f "$gDDTmpFolder"/dd_reports_filepath ]; then
        rm "$gDDTmpFolder"/dd_reports_filepath
    fi

    # delete save path from prefs
    defaults delete "$gUserPrefsFile" SaveDirectory

    gReportsFolderPath=""
}

# ---------------------------------------------------------------------------------------
OpenSaveDirectory()
{
    # open file path.
    if [ -f "$gDDTmpFolder"/dd_reports_filepath ]; then
        local filepath=$( cat "$gDDTmpFolder"/dd_reports_filepath )
        open $filepath
    fi
}

# ---------------------------------------------------------------------------------------
GetAndCheckUIPassword()
{
    message="$1" # Commas in the message cause it to fail!

    # Send message to UI to tell it we're waiting for user authentication
    echo "Waiting" > "$gDDTmpFolder"/dd_auth

    # revoke sudo permissions
    sudo -k

    gPw="$( /usr/bin/osascript << EOF -e 'set MyApplVar to do shell script "echo '"${message}"'"' -e 'Tell application "System Events" to display dialog MyApplVar default answer "" with hidden answer with icon 1' -e 'text returned of result' 2>/dev/null)"
    if [ ! "$gPw" == "" ]; then
        userNow=$( echo "$gPw" | sudo -S whoami )
        if [ "$userNow" == "root" ]; then
            return 0
        else
            return 1
        fi
    else
        # user canelled
        gPw="$gUiPwCancelledStr"

        ## Send message to UI to tell it no longer waiting for user authentication
        #echo "Done" > "$gDDTmpFolder"/dd_auth
        ClearAuthMessage
    fi
}

# ---------------------------------------------------------------------------------------
UIReturnSymlink()
{
    local uiReturn="$1"

    # remove temp file holding symlink info.
    if [ -f "$gDDTmpFolder"/dd_symlink ]; then
        rm "$gDDTmpFolder"/dd_symlink
    fi

    # remove everything up until, and including, the last colon
    uiReturn="${uiReturn##*:}"

    if [[ $uiReturn == *Symlink ]]; then # NOTE: uiReturn can be either "Create Symlink", "Update Symlink" or "Delete Symlink"

        GetAndCheckUIPassword "DarwinDumper requires your password to manage the symlink. Type your password to allow this."
        returnValueRoot=$? # 1 = not root / 0 = root

        if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then
            echo "$gPw" | sudo -S "$uiSudoChanges" "Symlink" "$SELF_PATH" "$uiReturn" && gPw=""

            # Get the status of the app symlink
            CheckSymLink

            ClearUIReturnMessages
            ClearAuthMessage

        elif [ ! "$gPw" == "$gUiPwCancelledStr" ]; then
            # As long as the user didn't cancel, run again.
            ClearUIReturnMessages
            UIReturnSymlink "$uiReturn"
        fi
    fi
}

# ---------------------------------------------------------------------------------------
UIReturnFixOwnPerm()
{
    GetAndCheckUIPassword "DarwinDumper requires your password to fix ownership/permissions. Type your password to allow this."
    returnValueRoot=$? # 1 = not root / 0 = root

    if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then
        echo "Fixing" > "$gDDTmpFolder"/dd_dumpfolder
        echo "$gPw" | sudo -S "$uiSudoChanges" "OwnPerm" "${DD_BOSS}" "${DD_BOSSGROUP}" "${gReportsFolderPath}" && gPw=""

        # Check change was successful
        CheckPathIsWriteable "$gReportsFolderPath"
        returnValueWriteable=$? # 1 = not writeable / 0 = writeable

        # If owner is root OR we can not write to it
        if [ ${returnValueWriteable} = 1 ]; then
            echo "NoWrite" > "$gDDTmpFolder"/dd_dumpfolder
        else
            echo "The $gAppReportsFolderName folder can now be written to."
            echo "Success" > "$gDDTmpFolder"/dd_dumpfolder
        fi

    elif [ ! "$gPw" == "$gUiPwCancelledStr" ]; then
        # As long as the user didn't cancel, run again.
        UIReturnFixOwnPerm
    elif [ "$gPw" == "$gUiPwCancelledStr" ]; then
        # user cancelled
        echo "NoWrite" > "$gDDTmpFolder"/dd_dumpfolder
    fi
}

# ---------------------------------------------------------------------------------------
WritePrefsToFile()
{
    # Write prefs file
    if [ -f "$gUserPrefsFile".plist ]; then
        defaults delete "$gUserPrefsFile"
    fi

    # Read the temp file then remove it.
    oIFS="$IFS"; IFS=$','
    uiReturnArray=( $(cat "$gDDTmpFolder"/dd_ui_return) )
    IFS="$oIFS"

    # Loop through each option
    for (( x=0; x<${#uiReturnArray[@]}; x++ ))
    do
        # Remove unwanted characters and parse results.
        case "${uiReturnArray[$x]##*:}" in
                "privacy")                 defaults write "$gUserPrefsFile" privacy True ;;
                "Report")                  defaults write "$gUserPrefsFile" Report True ;;
                "ArchiveZip")              defaults write "$gUserPrefsFile" ArchiveZip True ;;
                "ArchiveLzma")             defaults write "$gUserPrefsFile" ArchiveLzma True ;;
                "ArchiveNone")             defaults write "$gUserPrefsFile" ArchiveNone True ;;
                "acpi")                    defaults write "$gUserPrefsFile" acpi True ;;
                "acpiFromMem")             defaults write "$gUserPrefsFile" acpiFromMem True ;;
                "asl")                     defaults write "$gUserPrefsFile" asl True ;;
                "codecid")                 defaults write "$gUserPrefsFile" codecid True ;;
                "cpuinfo")                 defaults write "$gUserPrefsFile" cpuinfo True ;;
                "biosSystem")              defaults write "$gUserPrefsFile" biosSystem True ;;
                "biosVideo")               defaults write "$gUserPrefsFile" biosVideo True ;;
                "devprop")                 defaults write "$gUserPrefsFile" devprop True ;;
                "diskLoaderConfigs")       defaults write "$gUserPrefsFile" diskLoaderConfigs True ;;
                "bootLoaderBootSectors")   defaults write "$gUserPrefsFile" bootLoaderBootSectors True ;;
                "diskPartitionInfo")       defaults write "$gUserPrefsFile" diskPartitionInfo True ;;
                "dmi")                     defaults write "$gUserPrefsFile" dmi True ;;
                "edid")                    defaults write "$gUserPrefsFile" edid True ;;
                "bootlog")                 defaults write "$gUserPrefsFile" bootlog True ;;
                "firmmemmap")              defaults write "$gUserPrefsFile" firmmemmap True ;;
                "memIntelGraphics")        defaults write "$gUserPrefsFile" memIntelGraphics True ;;
                "ioreg")                   defaults write "$gUserPrefsFile" ioreg True ;;
                "kerneldmesg")             defaults write "$gUserPrefsFile" kerneldmesg True ;;
                "kernelinfo")              defaults write "$gUserPrefsFile" kernelinfo True ;;
                "kexts")                   defaults write "$gUserPrefsFile" kexts True ;;
                "lspci")                   defaults write "$gUserPrefsFile" lspci True ;;
                "rcscripts")               defaults write "$gUserPrefsFile" rcscripts True ;;
                "nvram")                   defaults write "$gUserPrefsFile" nvram True ;;
                "opencl")                  defaults write "$gUserPrefsFile" opencl True ;;
                "rtc")                     defaults write "$gUserPrefsFile" rtc True ;;
                "sip")                     defaults write "$gUserPrefsFile" sip True ;;
                "smc")                     defaults write "$gUserPrefsFile" smc True ;;
                "sysprof")                 defaults write "$gUserPrefsFile" sysprof True ;;
                "noshow")                  defaults write "$gUserPrefsFile" noshow True ;;
        esac
    done
    if [ "$gReportsFolderPath" != "$appRootPath" ] && [ "$gReportsFolderPath" != "$appRootPath"/"$gAppReportsFolderName" ]; then
        defaults write "$gUserPrefsFile" SaveDirectory "$gReportsFolderPath"
    fi

    # Set the ownership & permissions so it's readable.
    # This covers the case where creating the file as root.
    setPrefsOwnPerms
}

# ---------------------------------------------------------------------------------------
UIReturnRunRequest()
{
    oIFS="$IFS"; IFS=$','
    local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
    IFS="$oIFS"

    if [ $gFaceless -eq 0 ]; then
        WritePrefsToFile
    fi

    # Discover if user chose to run as root or not.
    local discoverRoot="${uiReturn##*:}"
    discoverRoot="${discoverRoot##*=}"
    discoverRoot="${discoverRoot%%,*}"

    if [ $discoverRoot -eq 1 ]; then
        # User chose to run as root.

        GetAndCheckUIPassword "DarwinDumper requires your password to run the selected dumps with root privileges. Type your password to allow this."
        returnValueRoot=$? # 1 = not root / 0 = root

        if [ ${returnValueRoot} = 0 ] && [ ! "$gPw" == "" ]; then

            ClearAuthMessage
            if [ "$gPw" == "$gUiPwCancelledStr" ]; then
                # user cancelled.
                ClearUIReturnMessages
                # Send UI message to reset all status' to idle.
                printf "X" >> "$gDDTmpFolder"/dd_completed
            else
                echo "$gPw" | sudo -S "${darwinDumperScript}" && gPw=""
                runOrQuit=1
            fi
        fi

    elif [ $discoverRoot -eq 0 ]; then
        # User chose to run without root privileges.
        "${darwinDumperScript}"
        runOrQuit=1
    fi

    return $runOrQuit
}

# ---------------------------------------------------------------------------------------
setPrefsOwnPerms()
{
    if [ -f "$gUserPrefsFile".plist ]; then
        chmod 755 "$gUserPrefsFile".plist
        chown "$theBoss":"$theBossGroup" "$gUserPrefsFile".plist
    fi
}

# ---------------------------------------------------------------------------------------
PerformRunChecks()
{
    DoesSavePathExist "$gReportsFolderPath"
    local pathExist=$? # 1 = no / 0 = yes
    if [ ${pathExist} = 0 ]; then

        CheckForExistingReportsDirAndAppend
        
        CheckPathIsWriteable "$gReportsFolderPath"
        local WriteablePath=$? # 1 = no / 0 = yes

        CheckSavePathForReportsName
        local hasReportsName=$? # 1 = no / 0 = yes
        if [ ${hasReportsName} = 1 ]; then
            gReportsFolderPath="${gReportsFolderPath}/${gAppReportsFolderName}"
        fi

        # If path is writable but DarwinDumperReports directory does not exist,
        # then create report directory. Only run if successful.
        if [ ${WriteablePath} = 0 ]; then
            if [ ${hasReportsName} = 1 ]; then
                createSaveDirAndSetPermissions "$gReportsFolderPath" "normal" "CreateSet" "UI" ""
                local returnMessage=$? # 1 = no / 0 = yes
                if [ ${returnMessage} = 0 ]; then
                    runDarwinDumperScript
                else
                    StopErrorPrintMessage "UI: STOP1"
                fi
            fi

        # If path is NOT writable AND DarwinDumperReports directory does not exist,
        # then create report directory. Only run if successful.
        else
            if [ ${hasReportsName} = 1 ]; then
                createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "CreateSet" "UI" "DarwinDumper requires root privileges to create the reports directory at your selected path: $gReportsFolderPath. Type your password to allow this."
                local returnMessage=$? # 1 = no / 0 = yes
                if [ ${returnMessage} = 0 ]; then
                    runDarwinDumperScript
                else
                    StopErrorPrintMessage "UI: STOP2"
                fi

            # If path is NOT writable AND DarwinDumperReports directory does exist,
            # then attempt to set ownership/permissions for the report directory.
            # Only run if successful.
            else
                createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "Set" "UI" "DarwinDumper requires root privileges to change ownership/permission to the reports directory. Type your password to allow this."
                local returnMessage=$? # 1 = no / 0 = yes
                if [ ${returnMessage} = 0 ]; then
                    runDarwinDumperScript
                else
                    StopErrorPrintMessage "UI: STOP3"
                fi
            fi
        fi

        # If path is writable AND DarwinDumperReports directory exists,
        # then run.
        if [ ${WriteablePath} = 0 ]; then
            if [ ${hasReportsName} = 0 ]; then
                runDarwinDumperScript
            fi
        fi
    else
        echo "*Save path: Error - Save path does not exist." >> "${gTmpPreLogFile}"
        # Send message to UI to notify the user
        echo "path_error" > "$gDDTmpFolder"/dd_error
        ClearUIReturnMessages
        ClearUIErrorMessage
        # Do nothing else, so return to main loop.
    fi
}

# ---------------------------------------------------------------------------------------
runDarwinDumperScript()
{
# Write save path to file for DarwinDumper script to use.
    echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
    UIReturnRunRequest
    runOrQuit=$? # Will initiate exit of main loop.
}

# ---------------------------------------------------------------------------------------
runUI()
{
    # Run the webview user interface as a child process
    # and direct it's results to a temporary file.
    `"${macgap}" &>"$gDDTmpFolder"/dd_ui_return` & pidDDUI=$! ; flagDDUI=0

    # Provide feedback.
    echo "DarwinDumper user interface is running."
    echo "Waiting for user..."

    # Check save path
    if [ ! "$gReportsFolderPath" == "" ]; then

        DoesSavePathExist "$gReportsFolderPath"
        local pathExist=$? # 1 = no / 0 = yes
        if [ ${pathExist} = 1 ]; then
            echo "*Error - Save path does not exist." >> "${gTmpPreLogFile}"
            # Write save path to file so UI can print it in dialog box.
            echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
            # Send message to UI to notify the user
            echo "path_error" > "$gDDTmpFolder"/dd_error
            ClearUIErrorMessage
        fi
    fi
    CheckAndFixBlankSavePath

    # Write save path to file.
    echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath

    # Check to see if symbolic link in /usr/local/bin/ has been created.
    CheckSymLink

    # Check to see if there's an update available
    CheckForUpdate

    local pw=""
    local userNow=""
    local runOrQuit=0
    while [ $runOrQuit -eq 0 ];
    do

        # Wait until temporary file exists and is greater than zero in size.
        while [ ! -s "$gDDTmpFolder"/dd_ui_return ];
        do
            sleep 0.25  # Check every 1/4 second.
        done

        # Check to see if user quit or not.
        if ! grep "user_quit" "$gDDTmpFolder"/dd_ui_return ; then

           # Is the UI informing that the user pressed the Symlink button?
            if grep "Symlink:" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                UIReturnSymlink "$uiReturn"

            # Has the UI informed that the status bars have been reset to idle?
            elif grep "idle" "$gDDTmpFolder"/dd_ui_return ; then
                  ClearUIReturnMessages
                  > "$gDDTmpFolder"/dd_completed                   # Clear $gDDTmpFolder/dd_completed as UI has now been reset.

            # Has the user agreed to fix ownership/permissions for Reports folder?
            elif grep "Fix" "$gDDTmpFolder"/dd_ui_return ; then
                  ClearUIReturnMessages
                  UIReturnFixOwnPerm

            # Has the UI returned an error message?
            elif grep "console" "$gDDTmpFolder"/dd_ui_return ; then
                  cat "$gDDTmpFolder"/dd_ui_return > ~/Desktop/DarwinDumperError.txt
                  ClearUIReturnMessages
                  echo "An error occurred. DarwinDumperError.txt was written to your Desktop."
                  echo "Exiting. Bye"
                  runOrQuit=1

            # Is the UI informing that the user wants to change the SaveDirectory?
            elif grep "saveDirectory" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                ClearUIReturnMessages
                GetNewSaveDirectory

            # Is the UI informing that the user wants to clear the SaveDirectory?
            elif grep "clearSaveDirectory" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                ClearUIReturnMessages
                ClearSaveDirectory
                CheckAndFixBlankSavePath
                # Write save path to file for DarwinDumper script to use.
                echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath

            # Is the UI informing that the user wants to open the SaveDirectory?
            elif grep "openSaveDirectory" "$gDDTmpFolder"/dd_ui_return ; then
                local uiReturn=$(cat "$gDDTmpFolder"/dd_ui_return)
                ClearUIReturnMessages
                OpenSaveDirectory

            # The UI is returning instructions for the dump options the user wants to run.
            else
                # Add temporary catch for 10.10 DP2 errors??
                tmp=$( grep "TSplicedFont" "$gDDTmpFolder"/dd_ui_return )
                if [ "$tmp" == "" ]; then
                    echo "*UI: User clicked the run button" >> "${gTmpPreLogFile}"
                    PerformRunChecks
                else
                    ClearUIReturnMessages
                fi
            fi
        else
            echo "User Quit. Bye"
            runOrQuit=1
        fi
    done

    # Wait until process ends.
    c=0
    while sleep 0.5; do
        kill -0 $pidDDUI &> /dev/null || if [ $flagDDUI -eq 0 ]; then ((c++)); flagDDUI=1; fi
        if [ $c -eq 1 ]; then
            break
        fi
    done
}

# ---------------------------------------------------------------------------------------
runCommandLine()
{
    local passedUser="$1"

    CheckAndFixBlankSavePath
    CheckForExistingReportsDirAndAppend

    DoesSavePathExist "$gReportsFolderPath"
    local pathExist=$? # 1 = no / 0 = yes
    if [ ${pathExist} = 1 ]; then
        echo "--------------------------------------------------------------------"
        echo "*Save path: Error - Save path does not exist." >> "${gTmpPreLogFile}"
        echo "Custom save path from user prefs does not exist, setting to default"
        gReportsFolderPath=""
        CheckAndFixBlankSavePath
        CheckForExistingReportsDirAndAppend
        echo "Save path is now: $gReportsFolderPath"
        echo "--------------------------------------------------------------------"
    fi

    CheckPathIsWriteable "$gReportsFolderPath"
    local WriteablePath=$? # 1 = no / 0 = yes

    CheckSavePathForReportsName
    local hasReportsName=$? # 1 = no / 0 = yes
    if [ ${hasReportsName} = 1 ]; then
        gReportsFolderPath="${gReportsFolderPath}/${gAppReportsFolderName}"
    fi

    # If path is writable but DarwinDumperReports directory does not exist,
    # then create report directory. Only run if successful.
    if [ ${WriteablePath} = 0 ]; then
        if [ ${hasReportsName} = 1 ]; then
            echo "------------------------------------------------------------------------"
            echo "Save path is writeable but DarwinDumperReports directory does not exist."
            echo "Attempting to creating DarwinDumperReports directory..."
            echo "------------------------------------------------------------------------"
            createSaveDirAndSetPermissions "$gReportsFolderPath" "normal" "CreateSet" "CL" ""
            local returnMessage=$? # 1 = no / 0 = yes
            if [ ${returnMessage} = 0 ]; then
                runDarwinDumperScriptCL "$passedUser"
            else
                StopErrorPrintMessage "CL: STOP1"
            fi
        fi

    # If path is NOT writable AND DarwinDumperReports directory does not exist,
    # then create report directory and set permissions. Only run if successful.
    else
        if [ ${hasReportsName} = 1 ]; then
            echo "----------------------------------------------------------------------------"
            echo "Save path is not writeable and DarwinDumperReports directory does not exist."
            echo "Attempting to creating DarwinDumperReports directory and set permissions..."
            echo "----------------------------------------------------------------------------"
            createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "CreateSet" "CL" ""
            local returnMessage=$? # 1 = no / 0 = yes
            if [ ${returnMessage} = 0 ]; then
                runDarwinDumperScriptCL "$passedUser"
            else
                StopErrorPrintMessage "CL: STOP2"
            fi

        # If path is NOT writable AND DarwinDumperReports directory does exist,
        # then attempt to set ownership/permissions for the report directory.
        # Only run if successful.
        else
            echo "----------------------------------------------------------------"
            echo "DarwinDumperReports directory does exist but it's not writeable."
            echo "Attempting to set permissions..."
            echo "----------------------------------------------------------------"
            createSaveDirAndSetPermissions "$gReportsFolderPath" "sudo" "Set" "CL" ""
            local returnMessage=$? # 1 = no / 0 = yes
            if [ ${returnMessage} = 0 ]; then
                runDarwinDumperScriptCL "$passedUser"
            else
                StopErrorPrintMessage "CL: STOP3"
            fi
        fi
    fi

    # If path is writable AND DarwinDumperReports directory exists,
    # then run.
    if [ ${WriteablePath} = 0 ]; then
        if [ ${hasReportsName} = 0 ]; then
            runDarwinDumperScriptCL "$passedUser"
        fi
    fi
}

# ---------------------------------------------------------------------------------------
runDarwinDumperScriptCL()
{
    local passedUser="$1"
    if [ $gFaceless -eq 0 ]; then
        WritePrefsToFile
    fi
    echo "$gReportsFolderPath" > "$gDDTmpFolder"/dd_reports_filepath
    if [ "$passedUser" == "" ]; then
        # Run main script - without root privileges.
        "$darwinDumperScript"
    elif [ "$passedUser" == "r" ]; then
        # Run main script - with root privileges.
        sudo "${darwinDumperScript}"
    fi
}

# ---------------------------------------------------------------------------------------
StopErrorPrintMessage()
{
    passedError="$1"
    echo "===========================================================" >> "$gTmpPreLogFile"
    echo "Error: $passedError" >> "$gTmpPreLogFile"
    echo "-----------------------------------------------------------" >> "$gTmpPreLogFile"
    echo "To help improve DarwinDumper, please send the containing temporary directory" >> "$gTmpPreLogFile"
    echo "together with a description of the problem to either of the following links:" >> "$gTmpPreLogFile"
    echo "http://www.insanelymac.com/forum/topic/282794-darwindumper/" >> "$gTmpPreLogFile"
    echo "http://www.projectosx.com/forum/index.php?showtopic=2447" >> "$gTmpPreLogFile"
    echo "-----------------------------------------------------------" >> "$gTmpPreLogFile"
    echo "" >> "$gTmpPreLogFile"
    echo "Thank you" >> "$gTmpPreLogFile"

    if [[ "$passedError" == *UI* ]]; then
        open "$gTmpPreLogFile"
        # Close the UI
        echo "Done" >> "$gDDTmpFolder"/dd_completed
        if [ -f "$gDDTmpFolder"/dd_completed ]; then
            chmod 755 "$gDDTmpFolder"/dd_completed
            chown "${theBoss}":"$theBossGroup" "$gDDTmpFolder"/dd_completed
        fi
    fi

    if [[ "$passedError" == *CL* ]]; then
        echo "==========================================================="
        echo "Error: $passedError"
        echo "-----------------------------------------------------------"
        echo "An error has occurred."
        echo "To help improve DarwinDumper, please send the temporary directory:"
        echo "$gDDTmpFolder"
        echo "together with a description of the problem to either of the following links:"
        echo "http://www.insanelymac.com/forum/topic/282794-darwindumper/"
        echo "http://www.projectosx.com/forum/index.php?showtopic=2447"
        echo "-----------------------------------------------------------"
        echo""
        echo "Thank you"
    fi

    exit 1
}

# ---------------------------------------------------------------------------------------
DeleteTempWorkingDirectory()
{
    if [ -d "$gDDTmpFolder" ]; then
        rm -rf "$gDDTmpFolder"
    fi
}

# -----------------------------------
# MAIN

# Remove any temp files as a precautionary measure.
# Just incase the app crashed and didn't clean up.
DeleteTempWorkingDirectory

# Create temporary working directory.
mkdir "$gDDTmpFolder"

# From http://stackoverflow.com/questions/7665/how-to-resolve-symbolic-links-in-a-shell-script/697552#697552
# get the absolute path of the executable
SELF_PATH=$(cd -P -- "$(dirname -- "$0")" && pwd -P) && SELF_PATH=$SELF_PATH/$(basename -- "$0")

# resolve symlinks
while [ -h "$SELF_PATH" ]; do
    # 1) cd to directory of the symlink
    # 2) cd to the directory of where the symlink points
    # 3) get the pwd
    # 4) append the basename
    DIR=$(dirname -- "$SELF_PATH")
    SYM=$(readlink "$SELF_PATH")
    SELF_PATH=$(cd $DIR && cd $(dirname -- "$SYM") && pwd)/$(basename -- "$SYM")
done

resourcesDir="${SELF_PATH%/*}"
if [ -d "$resourcesDir" ]; then
    toolsDir="$resourcesDir"/Tools
    csrStat="$toolsDir/csrstat"
fi

# Check os version
osVer=$( uname -r )
osVer="${osVer%%.*}"
if [ $osVer -ge 14 ]; then # Yosemite and newer

    # Check for csr-active-config hex setting
    sicHex=$( "$csrStat" | grep -o '(0x.*' | cut -c10-11 | tr [[:lower:]] [[:upper:]] )

    declare -a csrArr
    csrArr=($( "$csrStat" | grep -o ':.*' | tail -n 7 | tr -d ': ' ))
    [[ "${csrArr[0]}" == "enabled" ]] && gCSR_ALLOW_APPLE_INTERNAL=0      || gCSR_ALLOW_APPLE_INTERNAL=1
    [[ "${csrArr[1]}" == "enabled" ]] && gCSR_ALLOW_UNTRUSTED_KEXTS=0     || gCSR_ALLOW_UNTRUSTED_KEXTS=1
    [[ "${csrArr[2]}" == "enabled" ]] && gCSR_ALLOW_TASK_FOR_PID=0        || gCSR_ALLOW_TASK_FOR_PID=1
    [[ "${csrArr[3]}" == "enabled" ]] && gCSR_ALLOW_UNRESTRICTED_FS=0     || gCSR_ALLOW_UNRESTRICTED_FS=1
    [[ "${csrArr[4]}" == "enabled" ]] && gCSR_ALLOW_KERNEL_DEBUGGER=0     || gCSR_ALLOW_KERNEL_DEBUGGER=1
    [[ "${csrArr[5]}" == "enabled" ]] && gCSR_ALLOW_UNRESTRICTED_DTRACE=0 || gCSR_ALLOW_UNRESTRICTED_DTRACE=1
    [[ "${csrArr[6]}" == "enabled" ]] && gCSR_ALLOW_UNRESTRICTED_NVRAM=0  || gCSR_ALLOW_UNRESTRICTED_NVRAM=1

    gCSR_ALLOW_DEVICE_CONFIGURATION="0"
    
    sicBin="${gCSR_ALLOW_DEVICE_CONFIGURATION}${gCSR_ALLOW_UNRESTRICTED_NVRAM}${gCSR_ALLOW_UNRESTRICTED_DTRACE}${gCSR_ALLOW_APPLE_INTERNAL}${gCSR_ALLOW_KERNEL_DEBUGGER}${gCSR_ALLOW_TASK_FOR_PID}${gCSR_ALLOW_UNRESTRICTED_FS}${gCSR_ALLOW_UNTRUSTED_KEXTS}"
    #echo "SIP configuration: $sicBin (Internal kernel value: 0x$sicHex)"

    # Check for loaded kexts as they may be in the prelinked kernel already.
    gDrvLoadedD=0 # DirectHW.kext
    gDrvLoadedP=0 # pmem.kext
    gDrvLoadedR=0 # RadeonPCI.kext
    gDrvLoadedV=0 # VoodooHDA.kext
    kextstat | grep "DirectHW" &>/dev/null && gDrvLoadedD=1
    kextstat | grep "pmem" &>/dev/null && gDrvLoadedP=1
    kextstat | grep "RadeonPCI" &>/dev/null && gDrvLoadedR=1
    kextstat | grep "VoodooHDA" &>/dev/null && gDrvLoadedV=1

    # Save to file for UI to notify user of what cannot be done.
    echo "${gCSR_ALLOW_DEVICE_CONFIGURATION},${gCSR_ALLOW_UNRESTRICTED_NVRAM},${gCSR_ALLOW_UNRESTRICTED_DTRACE},${gCSR_ALLOW_APPLE_INTERNAL},${gCSR_ALLOW_KERNEL_DEBUGGER},${gCSR_ALLOW_TASK_FOR_PID},${gCSR_ALLOW_UNRESTRICTED_FS},${gCSR_ALLOW_UNTRUSTED_KEXTS}" > "$gDDTmpFolder"/dd_csr
    echo "${gDrvLoadedD},${gDrvLoadedP},${gDrvLoadedR},${gDrvLoadedV}" > "$gDDTmpFolder"/dd_loadedKexts
else
    gCSR_ALLOW_UNTRUSTED_KEXTS=1
    gCSR_ALLOW_UNRESTRICTED_FS=1
    gCSR_ALLOW_TASK_FOR_PID=1
    gCSR_ALLOW_KERNEL_DEBUGGER=1
    gCSR_ALLOW_APPLE_INTERNAL=1
    gCSR_ALLOW_UNRESTRICTED_DTRACE=1
    gCSR_ALLOW_UNRESTRICTED_NVRAM=1
    gCSR_ALLOW_DEVICE_CONFIGURATION=1
fi

# Was this script called from a script or the command line
# More info: # http://stackoverflow.com/questions/4261876/check-if-bash-script-was-invoked-from-a-shell-or-another-script-application
#identityCaller=`ps -o stat= -p $PPID`
identityCallerCheck=`ps -o stat= -p $$`

if [ "${identityCallerCheck:1:1}" == "+" ]; then

    # Called from command line so interpret arguments.
    # For getopts info: http://wiki.bash-hackers.org/howto/getopts_tutorial
    argumentsToPass=""
    wasDumpChosen=0

    # Check if any arguments were passed at all.
    if [ $# -ne 0 ]; then

        while getopts ":a:d:hlo:p:sv" opt; do
            case $opt in

              a) # ARCHIVES - Check the arguments
                 oIFS="$IFS"; IFS=$','
                 for o in $OPTARG
                 do
                     case "$o" in
                        "zip")              argumentsToPass="${argumentsToPass},ArchiveZip" ;;
                        "lzma")             argumentsToPass="${argumentsToPass},ArchiveLzma" ;;
                        "none")             argumentsToPass="${argumentsToPass},ArchiveNone" ;;
                             *)             echo "Invalid archive option: -$OPTARG" >&2
                                            exit 1
                                            ;;
                     esac
                 done
                 ;;

              d) # DUMPS -  Check the arguments
                 oIFS="$IFS"; IFS=$','
                 for o in $OPTARG
                 do
                     case "$o" in
                        "acpi")              argumentsToPass="${argumentsToPass},acpi"
                                             wasDumpChosen=1 ;;
                        "acpiFromMem")       argumentsToPass="${argumentsToPass},acpiFromMem"
                                             wasDumpChosen=1 ;;
                        "asl")               argumentsToPass="${argumentsToPass},asl"
                                             wasDumpChosen=1 ;;
                        "audio")             argumentsToPass="${argumentsToPass},codecid"
                                             wasDumpChosen=1
                                             if [ $gCSR_ALLOW_UNTRUSTED_KEXTS -eq 0 ] && [ $gDrvLoadedV -eq 0 ]
                                             then
                                                 echo "---------------------------------------------------------------"
                                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                                 echo "This means the VoodooHDA.kext cannot be loaded. The dump will"
                                                 echo "still be able to gather some information but not all."
                                             fi
                                             ;;
                        "biosSystem")        if [ $gCSR_ALLOW_UNTRUSTED_KEXTS -eq 0 ] && [ $gDrvLoadedD -eq 0 ]
                                             then
                                                 echo "---------------------------------------------------------------"
                                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                                 echo "This means the DirectHW.kext cannot be loaded and flashrom will"
                                                 echo "therefore not work."
                                             else
                                                 argumentsToPass="${argumentsToPass},biosSystem"
                                                 wasDumpChosen=1
                                             fi
                                             ;;
                        "biosVideo")         argumentsToPass="${argumentsToPass},biosVideo"
                                             wasDumpChosen=1
                                             if [ $gCSR_ALLOW_UNTRUSTED_KEXTS -eq 0 ] && [ $gDrvLoadedR -eq 0 ]
                                             then
                                                 echo "---------------------------------------------------------------"
                                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                                 echo "This means the RadeonPCI.kext cannot be loaded. The dump will"
                                                 echo "still be able to gather some information but not all."
                                             fi
                                             ;;
                        "bootlog")           argumentsToPass="${argumentsToPass},bootlog"
                                             wasDumpChosen=1 ;;
                        "cpuinfo")           argumentsToPass="${argumentsToPass},cpuinfo"
                                             wasDumpChosen=1 ;;
                        "devprop")           argumentsToPass="${argumentsToPass},devprop"
                                             wasDumpChosen=1 ;;
                        "diskLoaderConfigs") argumentsToPass="${argumentsToPass},diskLoaderConfigs"
                                             wasDumpChosen=1 ;;
                        "bootLoaderBootSectors")   argumentsToPass="${argumentsToPass},bootLoaderBootSectors"
                                             wasDumpChosen=1 ;;
                        "diskVolumeXuid")    argumentsToPass="${argumentsToPass},diskVolumeXuid"
                                             wasDumpChosen=1 ;;
                        "diskPartitionInfo") argumentsToPass="${argumentsToPass},diskPartitionInfo"
                                             wasDumpChosen=1 ;;
                        "dmi")               argumentsToPass="${argumentsToPass},dmi"
                                             wasDumpChosen=1 ;;
                        "edid")              argumentsToPass="${argumentsToPass},edid"
                                             wasDumpChosen=1 ;;
                        "firmmemmap")        if [ $gCSR_ALLOW_UNRESTRICTED_DTRACE -eq 0 ]
                                             then
                                                 echo "---------------------------------------------------------------"
                                                 echo "OS X System Integrity Protection is Enabled for dtrace."
                                                 echo "This means the firmware memory map dtrace script will fail."
                                             else
                                                 argumentsToPass="${argumentsToPass},firmmemmap"
                                                 wasDumpChosen=1
                                             fi
                                             ;;
                        "memIntelGraphics")  argumentsToPass="${argumentsToPass},memIntelGraphics"
                                             wasDumpChosen=1 ;;
                        "ioreg")             argumentsToPass="${argumentsToPass},ioreg"
                                             wasDumpChosen=1 ;;
                        "kerneldmesg")       argumentsToPass="${argumentsToPass},kerneldmesg"
                                             wasDumpChosen=1 ;;
                        "kernelinfo")        argumentsToPass="${argumentsToPass},kernelinfo"
                                             wasDumpChosen=1 ;;
                        "kexts")             argumentsToPass="${argumentsToPass},kexts"
                                             wasDumpChosen=1 ;;
                        "lspci")             if [ $gCSR_ALLOW_UNTRUSTED_KEXTS -eq 0 ] && [ $gDrvLoadedD -eq 0 ]
                                             then
                                                 echo "---------------------------------------------------------------"
                                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                                 echo "This means the DirectHW.kext cannot be loaded and lspci will"
                                                 echo "therefore not work."
                                             else
                                                 argumentsToPass="${argumentsToPass},lspci"
                                                 wasDumpChosen=1
                                             fi
                                             ;;
                        "nvram")             argumentsToPass="${argumentsToPass},nvram"
                                             wasDumpChosen=1 ;;
                        "opencl")            argumentsToPass="${argumentsToPass},opencl"
                                             wasDumpChosen=1 ;;
                        "rcscripts")         argumentsToPass="${argumentsToPass},rcscripts"
                                             wasDumpChosen=1 ;;
                        "rtc")               argumentsToPass="${argumentsToPass},rtc"
                                             wasDumpChosen=1 ;;
                        "sip")               argumentsToPass="${argumentsToPass},sip"
                                             wasDumpChosen=1 ;;
                        "smc")               argumentsToPass="${argumentsToPass},smc"
                                             wasDumpChosen=1 ;;
                        "sysprof")           argumentsToPass="${argumentsToPass},sysprof"
                                             wasDumpChosen=1 ;;
                        *)                   echo "Invalid dump: -$OPTARG" >&2
                                             exit 1
                                             ;;
                     esac
                 done
                 ;;

              h) echo ""
        echo "    -a                      Archive Options"
        echo "                            ----------------------------------------------------"
        echo "        zip                 Compress final dump folder using .zip"
        echo "        lzma                Compress final dump folder using .lzma"
        echo "        none                Do not compress the final dump folder"
        echo ""
        echo "    -d                      Dump Options"
        echo "                            ----------------------------------------------------"
        echo "        acpi                Extract ACPI tables from ioreg and decompile them."
        echo "        acpiFromMem         Extract any valid ACPI tables from memory.*"
        echo "        asl                 Reads last boot log from /var/log/asl/"
        echo "        audio               Run the getcodecid tool & temporarily install"
        echo "                            VoodooHDA.kext to run the getdump tool.*"
        echo "        biosSystem          Run the flashrom tool to dump system BIOS to file.*"
        echo "        biosVideo           Temporarily installs RadeonPCI.kext then runs the"
        echo "                            RadeonDump tool to dump video bios. This option"
        echo "                            will also decode the video bios if ATI vendor ID*"
        echo "        bootlog             Extracts the boot log from ioreg (uses bdmesg)."
        echo "        cpuinfo             Get CPU info"
        echo "        devprop             Extract device-properties from ioreg and convert"
        echo "                            using the gfxutil tool."
        echo "        diskLoaderConfigs   Scan mounted volumes for bootloader configuration"
        echo "                            files.* Note: requires root privileges to mount &"
        echo "                            read the EFI system partition."
        echo "        bootLoaderBootSectors     Combines diskutil list with added boot-sector / "
        echo "                            bootloader info.* Note: requires root privileges"
        echo "                            to mount & read the EFI system partition."
        echo "        diskVolumeXuid      Dump all Volume UUID's and Unique Partition GUID's*"
        echo "                            Note: requires root privileges to mount & read the"
        echo "                            EFI system partition."
        echo "        diskPartitionInfo   Save partition info from fdisk440 & gpt command."
        echo "                            Scan and interpret the disk sectors to build a view"
        echo "                            of the partition tables"
        echo "                            Note: requires root privileges to mount & read the"
        echo "                            EFI system partition."
        echo "        dmi                 Runs the smbios-reader tool then decodes the info"
        echo "                            using the dmidecode tool."
        echo "        edid                Extracts IODisplayEDID data from ioreg, then decodes"
        echo "                            it using the edid-decode tool."
        echo "        firmmemmap          Runs the FirmwareMemoryMap DTrace script to show the"
        echo "                            physical memory map from EFI.*"
        echo "        memIntelGraphics    Loads pmem.kext driver and then proceeds to write"
        echo "                            selected memory regions to disk.*"
        echo "        ioreg               Extract the live Registry to text file(s) and create"
        echo "                            IORegistry Web Viewer data structure."
        echo "        kerneldmesg         Dumps kernel boot message log using /sbin/dmesg*"
        echo "        kernelinfo          Dump CPU & Hardware info using /usr/sbin/sysctl"
        echo "        kexts               Runs /usr/sbin/kextstat to dump the list of"
        echo "                            currently loaded kernel extensions.*"
        echo "        lspci               Temporarily installs DirectHW.kext then runs the"
        echo "                            lspci tool to dump hardware information.*"
        echo "        rcscripts           Saves any rc.local and rc.shutdown.local scripts."
        echo "        nvram               Dump the contents of NVRAM."
        echo "        opencl              Runs the oclinfo tool to print data for compliant"
        echo "                            OpenCL devices."
        echo "        rtc                 Runs the cmosDumperForOsx tool to dump the current"
        echo "                            RTC registers."
        echo "        sip                 Runs Pike's cststat program to kernel get SIP status."
        echo "        smc                 Dumps all SMC keys to file using the SMC_util3 tool."
        echo "        sysprof             Runs /usr/sbin/system_profiler to save mini (non-"
        echo "                            sensitive contents) files (.xml and .txt)."
        echo ""
        echo "    -l                      Last settings (Use last options saved in user prefs)"
        echo ""
        echo "    -o                      Options"
        echo "                            ----------------------------------------------------"
        echo "        html                Build an HTML report file from dump information."
        echo "        private             Mask sensitive data within all the dumps."
        echo ""
        echo "    -p                      Pre-Configured Options"
        echo "                            ----------------------------------------------------"
        echo "        1                   Runs every dump that does not require root"
        echo "                            privileges, creates an HTML report & archives the"
        echo "                            final dump folder using .zip"
        echo "                            ** Use this option on it's own."
        echo "        2                   Runs every dump including those that require root"
        echo "                            privileges, creates an HTML report & archives the"
        echo "                            final dump folder using .zip."
        echo "                            ** Use this option on it's own."
        echo "        3                   Same as p1 but with privacy enabled."
        echo "        4                   Same as p2 but with privacy enabled."
        echo ""
        echo "    -s                      Print SIP status."
        echo ""
        echo "    -v                      Print the version."
        echo ""
        echo ""
        echo " Note: Items marked with an * require root privileges, to either run at all or"
        echo "       to perform completely."
        echo ""
        echo "Example: darwindumper -d bootLoaderBootSectors -o html -a zip -r"
        echo "Example: darwindumper -d smc,edid"
        echo "Example: darwindumper -d devprop,audio,bootlog,lspci"
        echo "Example: darwindumper -p1"
        echo "Example: darwindumper -l"
        echo ""
        ;;

              l) # LAST used options - read from user prefs.
                 LoadPreviousSettingsFromUserPrefs

                 if [ -f "$gDDTmpFolder"/dd_user_last_options ]; then
                     #declare -a rootDumps=(acpiFromMem codecid biosSystem biosVideo diskLoaderConfigs bootLoaderBootSectors diskVolumeXuid diskPartitionInfo firmmemmap memIntelGraphics kerneldmesg kexts lspci)
                     declare -a allDumps=(ArchiveZip acpi acpiFromMem asl codecid cpuinfo biosSystem biosVideo diskLoaderConfigs devprop bootLoaderBootSectors diskVolumeXuid diskPartitionInfo dmi edid bootlog firmmemmap memIntelGraphics ioreg kerneldmesg kernelinfo kexts lspci rcscripts nvram opencl rtc smc sysprof)
                     readOptions=( $(cat "$gDDTmpFolder"/dd_user_last_options))
                     for (( o=0; o<${#readOptions[@]}; o++ ))
                     do
                         if [ $gCSR_ALLOW_UNTRUSTED_KEXTS -eq 0 ]; then
                             if [ "${readOptions[$o]}" == "codecid" ] && [ $gDrvLoadedV -eq 0 ]; then
                                 echo "---------------------------------------------------------------"
                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                 echo "This means the VoodooHDA.kext cannot be loaded. But the audio"
                                 echo "dump still be able to gather some information but not all."
                             fi
                             if [ "${readOptions[$o]}" == "biosSystem" ] && [ $gDrvLoadedD -eq 0 ]; then
                                 echo "---------------------------------------------------------------"
                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                 echo "This means the DirectHW.kext cannot be loaded and flashrom will"
                                 echo "therefore not work."
                             fi
                             if [ "${readOptions[$o]}" == "biosVideo" ] && [ $gDrvLoadedR -eq 0 ]; then
                                 echo "---------------------------------------------------------------"
                                 echo "OS X System Integrity Protection is Enabled for unsigned kexts."
                                 echo "This means the RadeonPCI.kext cannot be loaded. The dump will"
                                 echo "still be able to gather some information but not all."
                             fi
                         fi
                         if [ $gCSR_ALLOW_UNRESTRICTED_DTRACE -eq 0 ]; then
                             if [ "${readOptions[$o]}" == "firmmemmap" ]; then
                                 echo "---------------------------------------------------------------"
                                 echo "OS X System Integrity Protection is Enabled for dtrace."
                                 echo "This means the firmware memory map dtrace script will fail."
                             fi
                         fi

                         for (( d=0; d<${#allDumps[@]}; d++ ))
                         do
                             if [ "${allDumps[$d]}" == "${readOptions[$o]}" ]; then
                                 wasDumpChosen=1
                             fi
                        done
                        argumentsToPass="$argumentsToPass,${readOptions[$o]}"
                     done
                 fi

                 if [ $wasDumpChosen -eq 0 ]; then
                     echo "Failed to read any previous dump options from prefs file."
                     echo "Please use a different option."
                     exit 1
                 fi
                 ;;

              o) # OPTIONS - Check the arguments
                 oIFS="$IFS"; IFS=$','
                 for o in $OPTARG
                 do
                     case "$o" in
                        "html")                   argumentsToPass="${argumentsToPass},Report" ;;
                        "private")                argumentsToPass="${argumentsToPass},privacy" ;;
                                *)                echo "Invalid option: -$OPTARG" >&2
                                                  exit 1
                                                  ;;
                     esac
                 done
                 ;;

              p) # PRECONFIGURED - Check the arguments
                 if [ "$OPTARG" == "1" ]; then
                     # Run all without root privileges
                     argumentsToPass=",ArchiveZip,acpi,asl,cpuinfo,devprop,dmi,edid,bootlog,ioreg,kernelinfo,rcscripts,nvram,opencl,rtc,sip,smc,sysprof,Report"
                     wasDumpChosen=1
                 elif [ "$OPTARG" == "2" ]; then
                    # Run as root
                     argumentsToPass=",ArchiveZip,acpi,acpiFromMem,asl,codecid,biosSystem,biosVideo,cpuinfo,diskLoaderConfigs,devprop,bootLoaderBootSectors,diskVolumeXuid,diskPartitionInfo,dmi,edid,bootlog,firmmemmap,memIntelGraphics,ioreg,kerneldmesg,kernelinfo,kexts,lspci,rcscripts,nvram,opencl,rtc,sip,smc,sysprof,Report"
                     wasDumpChosen=1
                 elif [ "$OPTARG" == "3" ]; then
                     # Run all without root privileges
                     argumentsToPass=",ArchiveZip,acpi,asl,cpuinfo,devprop,dmi,edid,bootlog,ioreg,kernelinfo,rcscripts,nvram,opencl,rtc,sip,smc,sysprof,Report,privacy"
                     wasDumpChosen=1
                 elif [ "$OPTARG" == "4" ]; then
                    # Run as root
                     argumentsToPass=",ArchiveZip,acpi,acpiFromMem,asl,codecid,cpuinfo,biosSystem,biosVideo,diskLoaderConfigs,devprop,bootLoaderBootSectors,diskVolumeXuid,diskPartitionInfo,dmi,edid,bootlog,firmmemmap,memIntelGraphics,ioreg,kerneldmesg,kernelinfo,kexts,lspci,rcscripts,nvram,opencl,rtc,sip,smc,sysprof,Report,privacy"
                     wasDumpChosen=1
                 fi
                 ;;
                 
              s) if [ $osVer -ge 15 ]; then # El Capitan or newer
                     echo "This OS X version supports Security Integrity Protection"
                     echo "SIP configuration: $sicBin (Internal kernel value: 0x$sicHex)"                 
                 elif [ $osVer -eq 14 ]; then # Yosemite
                     echo "SIP is not fully implemented in this version of OS X"
                     echo "SIP configuration: $sicBin (Internal kernel value: 0x$sicHex)"  
                 else
                     echo "SIP is not used in this version of OS X"
                 fi
                 exit 1
                 ;;

              v) echo "DarwinDumper v$VERS"
                 exit 1
                 ;;

              \?)
                 echo "Invalid option: -$OPTARG" >&2
                 exit 1
                 ;;

              :)
                 echo "Option -$OPTARG requires an argument." >&2
                 exit 1
                 ;;

            esac
        done


        if [ ! "$argumentsToPass" == "" ]; then

            # Check to see if a dump was asked for
            if [ $wasDumpChosen -eq 1 ]; then

                # Check if any dumps require root privileges
                declare -a rootDumps=(acpiFromMem codecid biosSystem biosVideo diskLoaderConfigs bootLoaderBootSectors diskVolumeXuid diskPartitionInfo firmmemmap memIntelGraphics kerneldmesg kexts lspci)
                rootFlag=0
                for (( r=0; r<${#rootDumps[@]}; r++ ))
                do
                    # do the arguments contain a dump requiring root privileges?
                    if test "${argumentsToPass#*${rootDumps[$r]}}" != "$argumentsToPass"; then
                        rootFlag=1
                    fi
               done

               echo "---------------------------------------------------------------"

               if [ $rootFlag -eq 1 ]; then
                    echo "Root privileges are required to complete this task."
                    argumentsToPass=":Root=1${argumentsToPass}"
                    echo "$argumentsToPass" >> "$gDDTmpFolder"/dd_ui_return
                    Initialise "CommandLine" "r"
               else
                    argumentsToPass=":Root=0${argumentsToPass}"
                    echo "$argumentsToPass" >> "$gDDTmpFolder"/dd_ui_return
                    Initialise "CommandLine" ""
               fi

            fi
        else
            exit 1
        fi

    else
        # No arguments were passed
        echo "usage: [-a zip,lzma,none] [-d acpi,asl,acpiFromMem,audio,biosSystem,biosVideo,codecid,cpuinfo,devprop,diskLoaderConfigs,bootLoaderBootSectors,diskVolumeXuid,diskPartitionInfo,dmi,edid,bootlog,firmmemmap,memIntelGraphics,ioreg,kerneldmesg,kernelinfo,kexts,lspci,rcscripts,nvram,opencl,rtc,sip,smc,sysprof] [-h] [-l] [-o html,private] [-p 1,2,3,4] [-v]"
    fi

else
    # Called from Finder application script so run UI.

    # Check for existence of "$gDDTmpFolder"/dd_completed
    # If found, remove.
    if [ -f "$gDDTmpFolder"/dd_completed ]; then
        rm "$gDDTmpFolder"/dd_completed
    fi

    if [ $gFaceless -eq 0 ]; then
        Initialise "Script" ""
    else
        echo ":Root=0,ArchiveZip,acpi,asl,cpuinfo,devprop,dmi,edid,bootlog,ioreg,kernelinfo,rcscripts,nvram,opencl,rtc,sip,smc,sysprof,html,noshow" >> "$gDDTmpFolder"/dd_ui_return
        Initialise "CommandLine" ""
    fi
fi

DeleteTempWorkingDirectory
